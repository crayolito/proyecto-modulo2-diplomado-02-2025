name: '🗑️ Destroy Infrastructure'

on:
  workflow_dispatch:
    inputs:
      confirm_destroy:
        description: 'Type "destroy" to confirm'
        required: true
        type: string
      environment:
        description: 'Environment to destroy'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging

env:
  TF_VERSION: '1.6.0'
  WORKING_DIR: './environments/dev'
  AWS_REGION: 'us-east-1'

jobs:
  destroy:
    name: '🗑️ Terraform Destroy'
    runs-on: ubuntu-latest
    if: github.event.inputs.confirm_destroy == 'destroy'
    environment: production

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Init
        run: terraform init
        working-directory: ${{ env.WORKING_DIR }}

      - name: Show what will be destroyed
        run: terraform plan -destroy
        working-directory: ${{ env.WORKING_DIR }}
        env:
          TF_VAR_project_name: ${{ secrets.TF_VAR_project_name }}
          TF_VAR_environment: ${{ secrets.TF_VAR_environment }}
          TF_VAR_aws_region: ${{ secrets.TF_VAR_aws_region }}

      - name: Terraform Destroy
        run: terraform destroy -auto-approve
        working-directory: ${{ env.WORKING_DIR }}
        env:
          TF_VAR_project_name: ${{ secrets.TF_VAR_project_name }}
          TF_VAR_environment: ${{ secrets.TF_VAR_environment }}
          TF_VAR_aws_region: ${{ secrets.TF_VAR_aws_region }}

      - name: Instalar jq
        if: always()
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq

      - name: Cleanup por nombre de proyecto (S3, EC2, IAM, WAF, Secrets, SSM)
        if: always()
        env:
          PREFIX: ${{ secrets.TF_VAR_project_name }}
          ENVIRONMENT: ${{ secrets.TF_VAR_environment }}
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          set -euo pipefail

          echo "Usando prefijo de proyecto: ${PREFIX} y environment: ${ENVIRONMENT}"

          # 1) S3 BUCKETS que comiencen con ${PREFIX}-${ENVIRONMENT} o ${PREFIX}-
          echo "==> Eliminando S3 buckets con prefijo"
          BUCKETS=$(aws s3api list-buckets --query "Buckets[?starts_with(Name, \`${PREFIX}-${ENVIRONMENT}\`) || starts_with(Name, \`${PREFIX}-\`)].Name" --output text | tr '\t' '\n' | sed '/^$/d' || true)
          for B in $BUCKETS; do
            echo "Bucket: $B"
            # Vaciar versiones y delete markers (si hay versionado)
            while true; do
              RESP=$(aws s3api list-object-versions --bucket "$B" --output json || echo '{}')
              CNT_VERS=$(echo "$RESP" | jq -r '.Versions | length // 0')
              CNT_DEL=$(echo "$RESP" | jq -r '.DeleteMarkers | length // 0')
              if [ "$CNT_VERS" -eq 0 ] && [ "$CNT_DEL" -eq 0 ]; then
                break
              fi
              echo "$RESP" \
                | jq -c '{Objects: (((.Versions // []) + (.DeleteMarkers // [])) | map({Key:.Key, VersionId:.VersionId}))}' \
                | aws s3api delete-objects --bucket "$B" --delete file:///dev/stdin >/dev/null || true
            done
            # Vaciar (no versionado) y eliminar bucket
            aws s3 rm "s3://$B" --recursive || true
            aws s3 rb "s3://$B" --force || true
          done

          # 2) EC2 INSTANCES con tag Name que empiece por ${PREFIX}- o Environment == ${ENVIRONMENT}
          echo "==> Terminando instancias EC2"
          INSTANCES=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=${PREFIX}-*" "Name=instance-state-name,Values=pending,running,stopping,stopped" \
                      "Name=tag:Environment,Values=${ENVIRONMENT}" \
            --query "Reservations[].Instances[].InstanceId" --output text | tr '\t' '\n' | sed '/^$/d' || true)
          if [ -n "${INSTANCES:-}" ]; then
            aws ec2 terminate-instances --instance-ids $INSTANCES || true
            aws ec2 wait instance-terminated --instance-ids $INSTANCES || true
          fi

          # 3) KEY PAIRS: ${PREFIX}-key
          echo "==> Eliminando KeyPairs"
          KP=$(aws ec2 describe-key-pairs --query "KeyPairs[?starts_with(KeyName, \`${PREFIX}-\`)].KeyName" --output text | tr '\t' '\n' | sed '/^$/d' || true)
          for K in $KP; do
            aws ec2 delete-key-pair --key-name "$K" || true
          done

          # 4) SECURITY GROUPS: ${PREFIX}-ec2-sg y ${PREFIX}-secure-ec2-sg
          echo "==> Eliminando Security Groups"
          for SG_NAME in "${PREFIX}-ec2-sg" "${PREFIX}-secure-ec2-sg"; do
            SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=${SG_NAME}" --query "SecurityGroups[].GroupId" --output text || true)
            if [ -n "$SG_ID" ]; then
              # Quitar reglas dependientes (por si bloquea)
              aws ec2 revoke-security-group-egress --group-id "$SG_ID" --ip-permissions '[]' || true
              aws ec2 revoke-security-group-ingress --group-id "$SG_ID" --ip-permissions '[]' || true
              aws ec2 delete-security-group --group-id "$SG_ID" || true
            fi
          done

          # 5) IAM: role/policy/instance profile -> ${PREFIX}-ec2-role / ${PREFIX}-ec2-policy / ${PREFIX}-ec2-profile
          echo "==> Eliminando IAM (Role/Policy/Profile)"
          ROLE="${PREFIX}-ec2-role"
          POLICY_NAME="${PREFIX}-ec2-policy"
          PROFILE="${PREFIX}-ec2-profile"

          # Instance Profile: quitar role y borrar profile
          if aws iam get-instance-profile --instance-profile-name "$PROFILE" >/dev/null 2>&1; then
            set +e
            ROLES_IN_PROFILE=$(aws iam get-instance-profile --instance-profile-name "$PROFILE" --query "InstanceProfile.Roles[].RoleName" --output text)
            for R in $ROLES_IN_PROFILE; do
              aws iam remove-role-from-instance-profile --instance-profile-name "$PROFILE" --role-name "$R"
            done
            set -e
            aws iam delete-instance-profile --instance-profile-name "$PROFILE" || true
          fi

          # Policy: localizar ARN por nombre y desapegar de role, luego borrar
          POLICY_ARN=$(aws iam list-policies --scope Local --query "Policies[?PolicyName==\`${POLICY_NAME}\`].Arn" --output text || true)
          if [ -n "$POLICY_ARN" ]; then
            ATTACHED=$(aws iam list-attached-role-policies --role-name "$ROLE" --query "AttachedPolicies[?PolicyArn==\`${POLICY_ARN}\`].PolicyArn" --output text 2>/dev/null || true)
            if [ -n "$ATTACHED" ]; then
              aws iam detach-role-policy --role-name "$ROLE" --policy-arn "$POLICY_ARN" || true
            fi
            aws iam delete-policy --policy-arn "$POLICY_ARN" || true
          fi

          # Role
          if aws iam get-role --role-name "$ROLE" >/dev/null 2>&1; then
            INLINE=$(aws iam list-role-policies --role-name "$ROLE" --query "PolicyNames[]" --output text || true)
            for P in $INLINE; do
              aws iam delete-role-policy --role-name "$ROLE" --policy-name "$P" || true
            done
            aws iam delete-role --role-name "$ROLE" || true
          fi

          # 6) WAFv2 WebACL: ${PREFIX}-waf-acl, scope REGIONAL
          echo "==> Eliminando WAFv2 Web ACL"
          WAF_NAME="${PREFIX}-waf-acl"
          WAF=$(aws wafv2 list-web-acls --scope REGIONAL --region "${AWS_REGION}" --query "WebACLs[?Name==\`${WAF_NAME}\`].[Id,LockToken]" --output text 2>/dev/null || true)
          if [ -n "$WAF" ]; then
            WAF_ID=$(echo "$WAF" | awk '{print $1}')
            WAF_LOCK=$(echo "$WAF" | awk '{print $2}')
            aws wafv2 delete-web-acl --scope REGIONAL --id "$WAF_ID" --name "$WAF_NAME" --lock-token "$WAF_LOCK" --region "${AWS_REGION}" || true
          fi

          # 7) Secrets Manager: ${PREFIX}-db-credentials-v2
          echo "==> Eliminando Secrets Manager"
          SECRET_NAME="${PREFIX}-db-credentials-v2"
          if aws secretsmanager describe-secret --secret-id "$SECRET_NAME" >/dev/null 2>&1; then
            if aws secretsmanager describe-secret --secret-id "$SECRET_NAME" --query "DeletedDate" --output text 2>/dev/null | grep -qv "None"; then
              aws secretsmanager restore-secret --secret-id "$SECRET_NAME" || true
            fi
            aws secretsmanager delete-secret --secret-id "$SECRET_NAME" --force-delete-without-recovery || true
          fi

          # 8) SSM Parameter: "/${PREFIX}/${ENVIRONMENT}/app-config"
          echo "==> Eliminando SSM Parameter"
          PARAM="/${PREFIX}/${ENVIRONMENT}/app-config"
          if aws ssm get-parameter --name "$PARAM" >/dev/null 2>&1; then
            aws ssm delete-parameter --name "$PARAM" || true
          fi

          echo "Cleanup por nombre de proyecto finalizado."

      - name: Cleanup VPCs por nombre de proyecto
        if: always()
        env:
          PREFIX: ${{ secrets.TF_VAR_project_name }}
          ENVIRONMENT: ${{ secrets.TF_VAR_environment }}
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          set -euo pipefail

          echo "==> Buscando VPCs con tags Project=${PREFIX} y Environment=${ENVIRONMENT}"
          VPCS=$(aws ec2 describe-vpcs \
            --filters "Name=tag:Project,Values=${PREFIX}" "Name=tag:Environment,Values=${ENVIRONMENT}" \
            --query "Vpcs[].VpcId" --output text | tr '\t' '\n' | sed '/^$/d' || true)

          if [ -z "${VPCS:-}" ]; then
            echo "No se encontraron VPCs para eliminar."
            exit 0
          fi

          for VPC in $VPCS; do
            echo "Procesando VPC: $VPC"

            # 0) Detener y eliminar interfaces de red no utilizadas (por seguridad)
            echo "   - Eliminando Network Interfaces no adjuntas"
            ENIS=$(aws ec2 describe-network-interfaces --filters "Name=vpc-id,Values=${VPC}" \
              --query "NetworkInterfaces[?Status=='available'].NetworkInterfaceId" --output text | tr '\t' '\n' | sed '/^$/d' || true)
            for ENI in $ENIS; do
              aws ec2 delete-network-interface --network-interface-id "$ENI" || true
            done

            # 1) Endpoints VPC
            echo "   - Eliminando VPC Endpoints"
            EP_IDS=$(aws ec2 describe-vpc-endpoints --filters "Name=vpc-id,Values=${VPC}" \
              --query "VpcEndpoints[].VpcEndpointId" --output text | tr '\t' '\n' | sed '/^$/d' || true)
            if [ -n "${EP_IDS:-}" ]; then
              aws ec2 delete-vpc-endpoints --vpc-endpoint-ids $EP_IDS || true
            fi

            # 2) NAT Gateways (por si existieran)
            echo "   - Eliminando NAT Gateways"
            NAT_IDS=$(aws ec2 describe-nat-gateways --filter "Name=vpc-id,Values=${VPC}" \
              --query "NatGateways[].NatGatewayId" --output text | tr '\t' '\n' | sed '/^$/d' || true)
            for NAT in $NAT_IDS; do
              aws ec2 delete-nat-gateway --nat-gateway-id "$NAT" || true
            done
            if [ -n "${NAT_IDS:-}" ]; then
              for NAT in $NAT_IDS; do
                aws ec2 wait nat-gateway-deleted --nat-gateway-ids "$NAT" || true
              done
            fi

            # 3) Internet Gateways
            echo "   - Desasociando y eliminando Internet Gateways"
            IGWS=$(aws ec2 describe-internet-gateways \
              --filters "Name=attachment.vpc-id,Values=${VPC}" \
              --query "InternetGateways[].InternetGatewayId" --output text | tr '\t' '\n' | sed '/^$/d' || true)
            for IGW in $IGWS; do
              aws ec2 detach-internet-gateway --internet-gateway-id "$IGW" --vpc-id "$VPC" || true
              aws ec2 delete-internet-gateway --internet-gateway-id "$IGW" || true
            done

            # 4) Route Tables (no-main)
            echo "   - Eliminando Route Tables no principales"
            RTBS=$(aws ec2 describe-route-tables --filters "Name=vpc-id,Values=${VPC}" \
              --query "RouteTables[].{Id:RouteTableId,Assoc:Associations}" --output json)
            IDS_NO_MAIN=$(echo "$RTBS" | jq -r '.[] | select([.Assoc[]?.Main] | any == false) | .Id' 2>/dev/null || true)
            for RT in $IDS_NO_MAIN; do
              # eliminar asociaciones explícitas
              ASSOCS=$(aws ec2 describe-route-tables --route-table-ids "$RT" \
                --query "RouteTables[].Associations[?Main==\`false\`].RouteTableAssociationId" --output text | tr '\t' '\n' | sed '/^$/d' || true)
              for A in $ASSOCS; do
                aws ec2 disassociate-route-table --association-id "$A" || true
              done
              aws ec2 delete-route-table --route-table-id "$RT" || true
            done

            # 5) Subnets
            echo "   - Eliminando Subnets"
            SUBNETS=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=${VPC}" \
              --query "Subnets[].SubnetId" --output text | tr '\t' '\n' | sed '/^$/d' || true)
            for S in $SUBNETS; do
              aws ec2 delete-subnet --subnet-id "$S" || true
            done

            # 6) Security Groups (excepto 'default')
            echo "   - Eliminando Security Groups (no default)"
            SGS=$(aws ec2 describe-security-groups --filters "Name=vpc-id,Values=${VPC}" \
              --query "SecurityGroups[?GroupName!=\`default\`].GroupId" --output text | tr '\t' '\n' | sed '/^$/d' || true)
            for SG in $SGS; do
              # intenta limpiar reglas (evita dependencias residuales)
              aws ec2 revoke-security-group-egress --group-id "$SG" --ip-permissions '[]' || true
              aws ec2 revoke-security-group-ingress --group-id "$SG" --ip-permissions '[]' || true
              aws ec2 delete-security-group --group-id "$SG" || true
            done

            # 7) NACLs custom (opcional, si los tuvieras; aquí no creamos, así que saltamos)

            # 8) VPC final
            echo "   - Eliminando VPC $VPC"
            aws ec2 delete-vpc --vpc-id "$VPC" || true
          done

          echo "Eliminación de VPCs finalizada."